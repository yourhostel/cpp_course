#include <iostream>
#include <fstream>
#include "utils.h"

using namespace std;


using namespace std;

int main() {
    const int n = 10; // Кількість чисел для обробки

    // --- Генерація послідовності випадкових чисел ---
    // Отримуємо вектор чисел у діапазоні [-10; 10] через сучасний генератор (Mersenne Twister)
    auto numbers = generate_random_numbers(n, -10, 10);

    int z, max; // z — робоча змінна для читання з файлу, max — шукаємо максимум

    // --- Відкриття бінарного файлу для запису ---
    // Файл відкривається у бінарному режимі (ios::binary), що дозволяє працювати з "сирими" байтами даних
    ofstream fout("binnum.dat", ios::binary);
    if (!fout) {
        cout << "Не вдалося відкрити файл для запису." << endl;
        return 1;
    }

    cout << "Згенеровано " << n << " чисел: ";

    // --- Запис чисел у бінарний файл ---
    for (int i = 0; i < n; ++i) {
        z = numbers[i]; // Отримуємо наступне число з вектора
        cout << z << " "; // Виводимо його для візуального контролю

        // Пишемо байтове представлення змінної z у файл
        // reinterpret_cast<const char*>(&z) — інтерпретує адресу змінної z як адресу масиву байтів
        // sizeof(int) — вказує скільки байтів треба записати (звичайно 4)
        fout.write(reinterpret_cast<const char*>(&z), sizeof(int));
    }

    fout.close(); // Закриваємо файл, щоб завершити операцію запису та гарантувати flush буфера
    cout << endl << "Числа записано у бінарний файл." << endl;

    // --- Відкриття бінарного файлу для читання ---
    // Тепер відкриваємо той же файл для читання байтів назад у змінну z
    ifstream fin("binnum.dat", ios::binary);
    if (!fin) {
        cout << "Не вдалося відкрити файл для читання." << endl;
        return 1;
    }

    cout << "Файл зчитано!" << endl;

    // --- Пошук максимального числа у бінарному файлі ---
    // Зчитуємо перше число з файлу одразу в змінну z, це і буде початкове значення для max
    if (fin.read(reinterpret_cast<char*>(&z), sizeof(int))) {
        max = z;
        cout << z << " "; // Виводимо перше зчитане значення
    } else {
        cout << "Файл пустий, нема що читати." << endl;
        return 1;
    }

    // --- Читання файлу блоками по 4 байти (розмір int) ---
    // Кожна ітерація зчитує чергові 4 байти з файлу у змінну z
    while (fin.read(reinterpret_cast<char*>(&z), sizeof(int))) {
        cout << z << " "; // Виводимо прочитане значення

        // Порівнюємо поточне значення з max, оновлюємо max при потребі
        if (z > max) {
            max = z;
        }
    }

    // Вивід фінального результату
    cout << endl << "Максимальне число у файлі: " << max << endl;

    fin.close(); // Закриваємо файл, завершуючи читання

    return 0;
}

