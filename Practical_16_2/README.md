# Практичне заняття 5. Програмування обробки динамічних масивів

## Приклад 1. Видалення нульових елементів з масиву `removeZerosFromArray()`

### Опис задачі
Необхідно створити динамічний масив та заповнити його випадковими цілими числами. Після цього слід видалити всі нульові елементи, змінивши розмір масиву.

### Розв’язок
1. Користувач задає кількість елементів `n`, після чого масив ініціалізується випадковими значеннями.
2. Під час заповнення масиву рахується кількість нулів `k`.
3. Після завершення ініціалізації виконується зсув елементів вліво: кожен нульовий елемент замінюється наступним.
4. Після зсуву змінюється розмір масиву за допомогою `realloc()`, вказуючи новий розмір `n-k`.
5. Виводиться оновлений масив, а після завершення роботи програми виділена пам’ять звільняється.

Цей підхід дозволяє видаляти нулі без використання додаткового явного масиву, оскільки зміна розміру відбувається через `realloc()`.  
Формально ми все ж створюємо новий масив, просто всередині `realloc()`.
![Screenshot from 2025-03-04 00-18-16.png](screenshots/Screenshot%20from%202025-03-04%2000-18-16.png)

---

## Приклад 2. Додавання заданої кількості нулів у початок масиву `prependZerosToArray()`

### Опис задачі
Потрібно створити динамічний масив цілих чисел та заповнити його випадковими значеннями, відмінними від нуля. Після цього користувач вказує, скільки нульових елементів (`k`) потрібно додати на початок масиву.  
Далі перевиділяється пам’ять за допомогою `realloc()`, вказуючи новий розмір `n + k`. Після цього всі елементи масиву зсуваються на `k` позицій вправо, а перші `k` позицій заповнюються нулями.  
Результат виводиться на екран, після чого пам'ять звільняється.

### Розв’язок
1. Користувач задає кількість елементів `n`, після чого створюється динамічний масив.
2. Масив заповнюється випадковими числами в діапазоні `[1, 9]`, щоб уникнути початкових нулів.
3. Користувач вводить `k` — кількість нулів, які потрібно додати.
4. Виконується перевиділення пам’яті через `realloc()`, збільшуючи розмір масиву до `n + k`.
5. Всі елементи масиву зсуваються на `k` позицій вправо.
6. Перші `k` елементів заповнюються нулями.
7. Виводиться оновлений масив, після чого виділена пам’ять звільняється.

Цей підхід дозволяє вставити нові елементи без використання додаткового масиву, економлячи пам’ять.
![Screenshot from 2025-03-04 00-28-34.png](screenshots/Screenshot%20from%202025-03-04%2000-28-34.png)

---

## Приклад 3. Вставка нового рядка у матрицю `insertRowToMatrix()`

### Опис задачі
Необхідно створити динамічну цілочисельну матрицю розміром `n × m`, де `n` та `m` задає користувач. Після цього потрібно вставити новий рядок на вказану позицію, зсунувши всі наступні рядки вниз.

### Розв’язок
1. Користувач задає кількість рядків `n` і стовпців `m`, після чого створюється динамічна матриця.
2. Матриця заповнюється випадковими числами в діапазоні `[-10, 10]`.
3. Користувач вводить `k` — індекс рядка, який потрібно додати.
4. Виконується перевиділення пам’яті через `resizeMatrix()`, збільшуючи кількість рядків на 1.
5. Всі рядки, починаючи з `k`, зсуваються на одну позицію вниз.
6. Новий рядок `k` заповнюється нулями.
7. Виводиться оновлена матриця, після чого виділена пам’ять звільняється.

Цей підхід дозволяє додавати рядки без використання додаткової матриці, економлячи пам’ять.
![Screenshot from 2025-03-04 00-43-16.png](screenshots/Screenshot%20from%202025-03-04%2000-43-16.png)

---

## Приклад 4. Вставка нового стовпця у матрицю `insertColumnToMatrix()`

### Опис задачі
Необхідно створити динамічну цілочисельну матрицю розміром `n × m`, де `n` та `m` задає користувач. Після цього потрібно вставити новий стовпець у вказаній позиції, зсунувши всі наступні елементи вправо.

### Розв’язок
1. Користувач задає кількість рядків `n` і стовпців `m`, після чого створюється динамічна матриця.
2. Матриця заповнюється випадковими числами в діапазоні `[-10, 10]`.
3. Користувач вводить `k` — індекс стовпця, який потрібно додати.
4. Виконується перевиділення пам’яті через `resizeMatrixColumns()`, збільшуючи кількість стовпців на 1.
5. В кожному рядку матриці всі елементи, починаючи з `k`, зсуваються на одну позицію вправо.
6. Новий стовпець `k` заповнюється нулями.
7. Виводиться оновлена матриця, після чого виділена пам’ять звільняється.

Цей підхід дозволяє додавати стовпці без використання додаткової матриці, економлячи пам’ять.
![Screenshot from 2025-03-04 00-57-31.png](screenshots/Screenshot%20from%202025-03-04%2000-57-31.png)

---

## Примітки до функцій

### Використання `randInRange()`
- У функціях `removeZerosFromArray()` та `prependZerosToArray()` використовується `randInRange(min, max)` для генерації випадкових чисел у заданому діапазоні.
- `randInRange()` базується на генераторі випадкових чисел **Mersenne Twister (`std::mt19937`)**, який забезпечує рівномірний розподіл і є надійнішим, ніж `rand()`.
- Функція приймає два аргументи — **мінімальне** та **максимальне** значення, а потім повертає випадкове число в цьому діапазоні.

### Використання `resizeArray()`
- Для перевиділення пам’яті використовується функція `resizeArray()`, яка виконує безпечний виклик `realloc()`.
- `resizeArray()` перевіряє, чи успішне виділення пам'яті:
    - Якщо `realloc()` повернув новий вказівник, він передається у викликаючу функцію.
    - Якщо `realloc()` повернув `nullptr`, програма повідомляє про помилку і очищає старий масив через `free(a);`.
#### Приклад використання:
```cpp
a = resizeArray(a, n + k);
if (!a) return; // Якщо realloc() провалився, функція завершується
```

#### Умова if відповідає за перевиділення пам'яті в функції resizeArray().
```cpp
if (const auto temp = realloc(...); temp != nullptr) {...}
```
#### Цей синтаксис C++17 називається "ініціалізація в умові if"
- Це покращує читабельність коду, оскільки змінна `temp` використовується лише в межах `if`.
- Спочатку виконується `const auto temp = realloc(...)`, а потім перевіряється `temp != nullptr`.
  (Безпека: Починаючи з C++11 `nullptr` замінив `NULL`. `NULL` та `0` можна випадково використати як ціле число, коли як `nullptr` можна присвоїти тільки вказівнику).

#### Чому `const auto temp` допустимо?
- `temp` створюється всередині `if` і не змінюється, тому `const` не заважає.
- `temp` існує лише в межах `if`, після нього пам'ять звільняється.

#### Чому `free(a);`, а не `delete[] a;`?
- `realloc()` працює тільки з `malloc()/free()`.
- `delete[]` використовується лише для `new[]`, а в цьому випадку масив виділяється через `realloc()`.

### Використання `resizeMatrix()`
- Функція `resizeMatrix()` виконує безпечне перевиділення пам’яті для збільшення кількості рядків у матриці.
- `resizeMatrix()` перевіряє, чи успішне виділення пам'яті:
    - Якщо виділення пам'яті успішне, новий вказівник повертається у викликаючу функцію.
    - Якщо пам'ять не вдалося виділити, програма повідомляє про помилку і завершує виконання.

#### Приклад використання:
```cpp
a = resizeMatrix(a, n + 1, m);
if (!a) return; // Якщо пам'ять не вдалося виділити, виходимо з функції
```

### Використання `resizeMatrixColumns()`
- Функція `resizeMatrixColumns()` виконує перевиділення пам’яті у кожному рядку матриці для збільшення кількості стовпців.
- `resizeMatrixColumns()` перевіряє, чи успішне виділення пам'яті:
    - Виділяється новий масив для кожного рядка з розміром `newCols`.
    - Якщо виділення пам'яті успішне, старі значення копіюються у новий масив.
    - Після цього старий масив видаляється (`delete[]`), а новий призначається на його місце.

#### Приклад використання:
```cpp
resizeMatrixColumns(a, n, m + 1);
```