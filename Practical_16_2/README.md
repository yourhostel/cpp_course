# Практичне заняття 5. Програмування обробки динамічних масивів

## Приклад 1. Видалення нульових елементів з масиву `removeZerosFromArray()`

### Опис задачі
Необхідно створити динамічний масив та заповнити його випадковими цілими числами. Після цього слід видалити всі нульові елементи, змінивши розмір масиву.

### Розв’язок
1. Користувач задає кількість елементів `n`, після чого масив ініціалізується випадковими значеннями.
2. Під час заповнення масиву рахується кількість нулів `k`.
3. Після завершення ініціалізації виконується зсув елементів вліво: кожен нульовий елемент замінюється наступним.
4. Після зсуву змінюється розмір масиву за допомогою `realloc()`, вказуючи новий розмір `n-k`.
5. Виводиться оновлений масив, а після завершення роботи програми виділена пам’ять звільняється.

![Screenshot from 2025-03-04 00-18-16.png](screenshots/Screenshot%20from%202025-03-04%2000-18-16.png)

---

## Приклад 2. Додавання заданої кількості нулів у початок масиву `prependZerosToArray()`

### Опис задачі
Потрібно створити динамічний масив цілих чисел та заповнити його випадковими значеннями, відмінними від нуля. Після цього користувач вказує, скільки нульових елементів (`k`) потрібно додати на початок масиву.  
Далі перевиділяється пам’ять за допомогою `realloc()`, вказуючи новий розмір `n + k`. Після цього всі елементи масиву зсуваються на `k` позицій вправо, а перші `k` позицій заповнюються нулями.  
Результат виводиться на екран, після чого пам'ять звільняється.

### Розв’язок
1. Користувач задає кількість елементів `n`, після чого створюється динамічний масив.
2. Масив заповнюється випадковими числами в діапазоні `[1, 9]`, щоб уникнути початкових нулів.
3. Користувач вводить `k` — кількість нулів, які потрібно додати.
4. Виконується перевиділення пам’яті через `realloc()`, збільшуючи розмір масиву до `n + k`.
5. Всі елементи масиву зсуваються на `k` позицій вправо.
6. Перші `k` елементів заповнюються нулями.
7. Виводиться оновлений масив, після чого виділена пам’ять звільняється.

![Screenshot from 2025-03-04 00-28-34.png](screenshots/Screenshot%20from%202025-03-04%2000-28-34.png)

---

## Приклад 3. Вставка нового рядка у матрицю `insertRowToMatrix()`

### Опис задачі
Необхідно створити динамічну цілочисельну матрицю розміром `n × m`, де `n` та `m` задає користувач. Після цього потрібно вставити новий рядок у вказану позицію, зсунувши всі наступні рядки вниз.

### Розв’язок
1. **Створення матриці**:
   - Користувач вводить кількість рядків `n` і стовпців `m`.
   - Виділяється пам’ять під `n` покажчиків (`malloc(n * sizeof(int*))`).
   - Для кожного рядка виділяється `m` елементів (`malloc(m * sizeof(int))`).
2. **Заповнення матриці випадковими числами** в діапазоні `[-10, 10]`.
3. **Введення індексу `k` нового рядка**.
4. **Розширення пам’яті**:
   - Використовується `realloc()` для збільшення масиву покажчиків.
   - Виділяється новий рядок (`malloc(m * sizeof(int))`).
5. **Зсув рядків вниз**.
6. **Заповнення нового рядка нулями**.
7. **Вивід оновленої матриці**.
8. **Очищення пам'яті**.

![Screenshot from 2025-03-04 00-43-16.png](screenshots/Screenshot%20from%202025-03-04%2000-43-16.png)

---

## Приклад 4. Вставка нового стовпця у матрицю `insertColumnToMatrix()`

### Опис задачі
Необхідно створити динамічну цілочисельну матрицю розміром `n × m`, де `n` та `m` задає користувач. Після цього потрібно вставити новий стовпець у вказаній позиції, зсунувши всі наступні елементи вправо.

### Розв’язок
1. **Створення матриці**:
   - Користувач вводить `n` та `m`.
   - Виділяється пам’ять під `n` покажчиків (`malloc(n * sizeof(int*))`).
   - Для кожного рядка виділяється `m` елементів (`malloc(m * sizeof(int))`).
2. **Заповнення матриці випадковими числами**.
3. **Введення індексу `k` для вставки стовпця**.
4. **Розширення пам’яті**:
   - Для кожного рядка використовується `realloc()`, щоб збільшити кількість стовпців на 1.
5. **Зсув елементів у кожному рядку вправо**.
6. **Заповнення нового стовпця нулями**.
7. **Виведення оновленої матриці**.
8. **Очищення пам'яті**.

![Screenshot from 2025-03-04 00-57-31.png](screenshots/Screenshot%20from%202025-03-04%2000-57-31.png)

---

## Примітки до функцій

### Використання `randInRange()`
- У всіх функціях, де відбувається заповнення масиву чи матриці випадковими числами, використовується `randInRange(min, max)` у заданому діапазоні.
- `randInRange()` базується на генераторі випадкових чисел **Mersenne Twister (`std::mt19937`)**, який забезпечує рівномірний розподіл і є надійнішим, ніж `rand()`.
- Функція приймає два аргументи — **мінімальне** та **максимальне** значення, а потім повертає випадкове число в цьому діапазоні.

### Використання `resizeArray()`
- Для перевиділення пам’яті використовується функція `resizeArray()`, яка виконує безпечний виклик `realloc()`.
- `resizeArray()` перевіряє, чи успішне виділення пам'яті:
    - Якщо `realloc()` повернув новий вказівник, він передається у викликаючу функцію.
    - Якщо `realloc()` повернув `nullptr`, програма повідомляє про помилку і очищає старий масив через `free(a);`.
#### Приклад використання:
```cpp
a = resizeArray(a, n + k);
if (!a) return; // Якщо realloc() провалився, функція завершується
```

#### Умова if відповідає за перевиділення пам'яті в функції resizeArray().
```cpp
if (const auto temp = realloc(...); temp != nullptr) {...}
```
#### Цей синтаксис C++17 називається "ініціалізація в умові if"
- Це покращує читабельність коду, оскільки змінна `temp` використовується лише в межах `if`.
- Спочатку виконується `const auto temp = realloc(...)`, а потім перевіряється `temp != nullptr`.
  (Безпека: Починаючи з C++11 `nullptr` замінив `NULL`. `NULL` та `0` можна випадково використати як ціле число, коли як `nullptr` можна присвоїти тільки вказівнику).

#### Чому `const auto temp` допустимо?
- `temp` створюється всередині `if` і не змінюється, тому `const` не заважає.
- `temp` існує лише в межах `if`, після нього пам'ять звільняється.

#### Чому `free(a);`, а не `delete[] a;`?
- `realloc()` працює тільки з `malloc()/free()`.
- `delete[]` використовується лише для `new[]`, а в цьому випадку масив виділяється через `realloc()`.

### Використання `resizeMatrixRows()`
- Функція `resizeMatrixRows()` виконує перевиділення пам’яті для збільшення кількості рядків у матриці.
- `resizeMatrixRows()` перевіряє, чи успішне виділення пам'яті:
  - Виділяється новий масив покажчиків для рядків.
  - Якщо `realloc()` повертає `nullptr`, пам’ять очищується, і функція повертає `nullptr`.
  - Для нового рядка виділяється окремий масив розміром `cols`.
  - Якщо виділення пам’яті для нового рядка не вдалося, звільняються всі раніше виділені рядки, і функція завершується.
#### Приклад використання:
```cpp
a = resizeMatrixRows(a, n + 1, m);
if (!a) {
    cout << "Помилка перевиділення пам'яті!" << endl;
    return;
}
```

### Використання `resizeMatrixColumns()`
- Функція `resizeMatrixColumns()` виконує перевиділення пам’яті у кожному рядку матриці для збільшення кількості стовпців.
- `resizeMatrixColumns()` перевіряє, чи успішне виділення пам'яті:
  - Для кожного рядка виділяється новий масив із розміром `newCols`.
  - Якщо пам’ять не вдалося перевиділити, відбувається очищення всієї матриці.
  - Щоб уникнути висячих покажчиків, при помилці `a` обнуляється.
#### Приклад використання:
```cpp
if (!resizeMatrixColumns(&a, n, m + 1)) {
    cout << "Помилка перевиділення пам'яті!" << endl;
    return;
}
```

### Висновок
У роботі використано **нативне керування пам’яттю через `malloc()`, `free()`, `realloc()`, без використання `new[]` і `delete[]` для створення та видалення масивів і матриць. Хоча `realloc()` змінює розмір масиву "на місці", насправді він може створювати новий масив і копіювати туди дані, якщо не вдається розширити пам’ять у поточному місці. Це дає змогу динамічно змінювати розмір масивів та матриць. Очищення пам’яті виконується через `free()`, оскільки `realloc()` повертає вказівник, сумісний лише з `malloc()/free()`, навіть якщо початкове виділення пам’яті було виконане через `realloc()`. Такий підхід дозволяє ефективно керувати пам’яттю, мінімізуючи витрати на копіювання.
