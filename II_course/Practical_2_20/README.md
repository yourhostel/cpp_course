# Методи сортування масивів

## [ Алгоритм сортування бульбашкою ](https://en.wikipedia.org/wiki/Cocktail_shaker_sort) ([`bubbleSort`](https://github.com/yourhostel/cpp_course/blob/main/Practical_2_20/bubble_sort.cpp))

- **Метод:** багаторазові обміни сусідніх елементів, поки найбільші “вспливають” нагору

Функція `bubbleSort(int arr[], int n)` сортує масив на місці (in-place), тобто:

![Screenshot from 2025-04-14 22-09-20.png](screenshots/Screenshot%20from%202025-04-14%2022-09-20.png)

#### Складність:
- Гірший випадок (worst-case): O(n²)
- [ ] Масив повністю в зворотному порядку.
- [ ] Потрібно максимальна кількість обмінів і порівнянь.
- [ ] Кожен елемент треба “перетягнути” через увесь масив.
- Середній випадок (average-case): O(n²)
- [ ] Масив у випадковому порядку.
- [ ] Теж багато обмінів, але трохи менше, ніж у найгіршому.
- [ ] Теж квадратична складність — бо кожен елемент проходиться багато разів.
- Ліпший випадок (best-case): O(n)
- [ ] Масив вже відсортований.
- [ ] Якщо реалізована оптимізація — наприклад, прапорець swapped = false:
```c++
for (...) {
    swapped = false;
    for (...) {
        if (a[j-1] > a[j]) {
            swap(...);
            swapped = true;
        }
    }
    if (!swapped) break; // Вихід, бо більше нічого не міняється
}
```
- [ ] Тоді одразу після першого проходу без змін — цикл зупиняється, отже O(n).

## Покращення алгоритму бульбашки

### 1. Раннє завершення (`swapped = false`)
- Якщо під час проходу не було жодного обміну — масив уже впорядкований.
- Дає найкращий результат на майже або повністю відсортованих масивах.
- Складність в найкращому випадку знижується до O(n).

### 2. Запам’ятовування останнього обміну
- Якщо на проході відбувався обмін на позиції `k`, то всі елементи після `k` вже впорядковані.
- Наступний прохід можна закінчити на `k`, а не доходити до `n - i - 1`.
- Це значно зменшує кількість непотрібних порівнянь.

### 3. Шейкер-сортування (двостороння бульбашка)
- Замість сортування тільки знизу вгору, чергуються напрямки: спочатку знизу вгору, потім зверху вниз.
- Це дозволяє одночасно “випливати” малим елементам вліво і “тонути” великим вправо.
- Зменшує загальну кількість проходів у випадках типу: `[6, 1, 2, 3, 4, 5] `

![Sorting_shaker_sort_anim.gif](screenshots/Sorting_shaker_sort_anim.gif)

| Покращення               | Ефект                          |
|--------------------------|--------------------------------|
| `swapped = false`        | Раннє завершення при впорядкованості |
| `lastSwapIndex`          | Скорочення зони перегляду       |
| Шейкер-сортування        | Прискорення при “важких хвостах”|

---
 
## [ Алгоритм сортування вибором ](https://en.wikipedia.org/wiki/Selection_sort) ([`selectSort`](https://github.com/yourhostel/cpp_course/blob/main/Practical_2_20/select_sort.cpp))

![Selection_sort_animation.gif](screenshots/Selection_sort_animation.gif)

- **Метод:** послідовне знаходження найменшого елемента і вставлення його в потрібне місце зліва.

Функція `selectSort(int arr[], int n)` сортує масив на місці (in-place), тобто:

![Screenshot from 2025-04-14 22-47-27.png](screenshots/Screenshot%20from%202025-04-14%2022-47-27.png)

#### Складність:

- Гірший випадок (worst-case): O(n²)
    - [ ] Масив повністю в зворотному порядку.
    - [ ] Потрібно пройти по кожному елементу й знайти мінімум у решті масиву.
    - [ ] Кількість порівнянь велика, але кількість обмінів невелика (до `n-1`).

- Середній випадок (average-case): O(n²)
    - [ ] Масив у випадковому порядку.
    - [ ] Алгоритм не залежить від розташування елементів.
    - [ ] Кожен раз здійснюється повний пошук мінімуму.

- Ліпший випадок (best-case): O(n²)
    - [ ] Навіть якщо масив уже відсортований, алгоритм все одно шукає мінімум.
    - [ ] Без оптимізації кількість порівнянь не зменшується.

#### Особливості:

- Кількість обмінів менша, ніж у бульбашки — максимум `n - 1`.
- Добре працює, якщо обмін — дорога операція (наприклад, великі структури).
- Не адаптивний без додаткових покращень (навіть впорядковані масиви не зупиняє).

---

## [ Алгоритм сортування вставками ](https://en.wikipedia.org/wiki/Insertion_sort) ([`insertSort`](https://github.com/yourhostel/cpp_course/blob/main/Practical_2_20/insert_sort.cpp))

![Insertion_sort.gif](screenshots/Insertion_sort.gif)

- Метод: на кожному кроці черговий елемент вставляється в правильне місце у вже впорядковану частину масиву.

Функція `insertSort(int arr[], int n)` сортує масив на місці (in-place), тобто:

![Screenshot from 2025-04-14 23-01-23.png](screenshots/Screenshot%20from%202025-04-14%2023-01-23.png)

#### Складність:

- Гірший випадок (worst-case): O(n²)
  - [ ] Масив повністю в зворотному порядку.
  - [ ] Кожен новий елемент проходить через усю впорядковану частину.
  - [ ] Багато зсувів елементів вправо.

- Середній випадок (average-case): O(n²)
  - [ ] Масив у випадковому порядку.
  - [ ] Вставка з частковим зсуванням елементів.
  - [ ] Кожен елемент "просіюється" вглиб, можливо кілька разів.

- Ліпший випадок (best-case): O(n)
  - [ ] Масив вже відсортований.
  - [ ] Кожен елемент одразу залишається на місці, зсувів немає.
  - [ ] Тільки по одному порівнянню на крок.

#### Особливості:

- Добре працює для майже відсортованих масивів.
- Кількість зсувів зазвичай менша, ніж кількість обмінів у bubble sort.
- Сортує на місці, стабільний алгоритм (зберігає порядок однакових елементів).


