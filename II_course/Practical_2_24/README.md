# Робота з бінарними файлами в C++

## Бінарний файл
- Це послідовність **байтів**, які зберігаються у тому ж вигляді, як у пам’яті комп’ютера.
- Жодних `\n`, жодних текстових конвенцій.
- Ти сам вирішуєш, що значить кожен байт.

---

## Основні класи роботи з файлами

| Клас      | Для чого               | Методи, які юзаються |
|-----------|------------------------|---------------------|
| **ifstream** | Вхідний потік (читання)   | `open()`, `read()`, `seekg()`, `tellg()` |
| **ofstream** | Вихідний потік (запис)    | `open()`, `write()`, `seekp()`, `tellp()` |
| **fstream**  | Двосторонній потік (читання + запис) | Все те саме |

---

## Методи потоків

| Метод          | Для чого                        | Приклад                         |
|----------------|---------------------------------|----------------------------------|
| **write()**    | Запис байтів у файл             | `fout.write((char*)&p, sizeof(p));` |
| **read()**     | Зчитування байтів з файлу        | `fin.read((char*)&p, sizeof(p));` |
| **seekg()**    | Переміщення курсору читання      | `fin.seekg(5, ios::beg);` |
| **seekp()**    | Переміщення курсору запису       | `fout.seekp(5, ios::end);` |
| **tellg()**    | Де зараз курсор читання          | `fin.tellg();` |
| **tellp()**    | Де зараз курсор запису           | `fout.tellp();` |

---

## Позиціонування курсора

| Аргумент    | Що означає |
|-------------|-----------|
| **ios::beg** | Відлік від початку файлу |
| **ios::cur** | Відлік від поточної позиції |
| **ios::end** | Відлік від кінця файлу |

---

## Приклад: запис і читання структури

```c++
struct student {
    char name[15];
    int age;
    bool gender;
};

// Запис
ofstream fout("students.dat", ios::binary);
student s = {"Ivan", 22, 1};
fout.write((char*)&s, sizeof(s));
fout.close();

// Читання
ifstream fin("students.dat", ios::binary);
student s2;
fin.read((char*)&s2, sizeof(s2));
fin.close();
```

## Вирівнювання (Padding) у структурах

Структури в C++ можуть містити `порожні байти (padding)` для вирівнювання полів під архітектуру CPU.

- Це означає, що `розмір структури може бути більший`, ніж сума розмірів її полів.
- `sizeof(struct)` дасть фактичний розмір з урахуванням паддінгу.

### Як уникнути паддінгу:
```c++
#pragma pack(push, 1)
struct student {
    char name[15];
    int age;
    bool gender;
};
#pragma pack(pop)
```

## Про порядок байтів (Endianness)
> Якщо працювати з ARM, мережами або крос-платформеними файлами.

- `Little-endian` (Intel x86) — молодший байт записується першим.
- `Big-endian` (мережі, деякі архітектури) — старший байт першим.

### Приклад проблеми:
- Запис `int = 0x12345678` на x86 (little-endian).
- На big-endian машині це буде зчитано як `0x78563412`.

| Формат  | Що це      | Скільки       |
|---------|------------|---------------|
| 1 байт  | 8 біт      | 2 hex символи |
| 0x12    | 0001 0010  | 1 байт        |
| 0xAB    | 1010 1011  | 1 байт        |

- Маєм значення `int x = 0x12345678;`

| Порядок | Адреса | Значення |
| ------- | ------ | -------- |
| Байт №0 | x+0    | 0x78     |
| Байт №1 | x+1    | 0x56     |
| Байт №2 | x+2    | 0x34     |
| Байт №3 | x+3    | 0x12     |

#### Відображення в пам’яті x86 (little-endian):

> `[ 78 ] [ 56 ] [ 34 ] [ 12 ]`

- зчитуємо як:

> `uint32_t x = *(uint32_t*)адреса;`

- отримуємо `x = 0x12345678`

#### Відображення в пам’яті на big-endian машині:

> `[ 12 ] [ 34 ] [ 56 ] [ 78 ]`

### Як вирішити:
- Використовувати функції для конвертації:
  - `htons()`, `htonl()` — host to network
  - `ntohs()`, `ntohl()` — network to host
- Або робити байт-маніпуляції руками:
```c++
uint32_t x = 0x12345678;
uint8_t b0 = (x >> 0) & 0xFF;
uint8_t b1 = (x >> 8) & 0xFF;
uint8_t b2 = (x >> 16) & 0xFF;
uint8_t b3 = (x >> 24) & 0xFF;
```

## Структури з ідентифікаторами (magic marker)

Щоб уникнути плутанини, коли структура може з'явитись у файлі неочікувано, додають ідентифікатори.

### Приклад формату:

`[TypeMarker (4 байти)][Size (4 байти)][Data...]`

### Запис:
```c++
const char marker[4] = {'S', 'T', 'U', 'D'};
uint32_t dataSize = sizeof(student);

fout.write(marker, 4);
fout.write((char*)&dataSize, sizeof(dataSize));
fout.write((char*)&s, sizeof(s));
```

### Читання:
```c++
char marker[4];
uint32_t dataSize;

fin.read(marker, 4);
fin.read((char*)&dataSize, sizeof(dataSize));
if (strncmp(marker, "STUD", 4) == 0) {
student s;
fin.read((char*)&s, dataSize);
}
```

- Це дозволяє гарантовано знаходити початок структур і захищає від випадкових збігів байтів всередині даних.

## Великі файли: буферизація та mmap

- Зчитувати файли по байту — повільно і безглуздо.
- Тому використовують `буфери`: читають відразу шматок даних, а потім працюють з ним у пам’яті.
- Наприклад, зчитування блоками по 4КБ:

```c++
char buffer[4096];
fin.read(buffer, sizeof(buffer));
```
### Такий підхід використовується у:

- файлових системах (наприклад, ext4 блочна архітектура 4КБ)
- базах даних (SQLite, RocksDB працюють сторінками по 4КБ або 16КБ)
- кешах та файлових стрімах.

### mmap (memory-mapped files):

- Для ще більш швидкої роботи використовують memory mapping (mmap).
- Файл відображається у пам’ять, потім працюємо з ним як з масивом байтів у RAM.
- Це зручно для великих файлів, які важко читати цілими шматками в RAM.

