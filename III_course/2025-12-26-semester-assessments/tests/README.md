# Перевірка тестів:

---

## ООП МК (ІІ)+

1. `sys.getsizeof()` для `range` просто тримає компактно розмітку без значень розмір малий, бо лінивий об'єкт
  - `range start = 0; stop = 10000; step = 1` 
  - `[x for x in range(0, 10000)]` реально створюється список з 10000 елементів
2. `[('a', 'b'), ('c', 'd'), ('e', 'f')]` список кортежів, логічно таблиця 3x2
  - `*original` розпаковує список у окремі аргументи для `zip`
  - `zip` бере елементи з однаковими індексами, перший прохід дає `('a','c','e')`, другий `('b','d','f')`. Виходить транспонування рядків і колонок.
3. _
  - `starmap` розпаковує кожен кортеж і передає його елементи як окремі аргументи функції
  - `pow`, `max` і `min` застосовуються до кожного набору аргументів незалежно
4. Словник `dict` створюється з унікальних символів рядка, їх у `'1,2,3'` 4, тому й 4 ключі.
5. _
  - `{i**2 for i in range(10)}` - створює множину квадратів чисел, тому порядок не гарантується і зберігаються лише унікальні значення
  - `{i: i**2 for i in range(10)}`- створює словник, де ключ це число `i`, а значення його квадрат
6. Ітератор `iter` повертає елементи по черзі а коли закінчується `next` замість помилки повертає значення за замовчуванням `STOP`
7. `OrderedDict` зберігає порядок додавання ключів і виводить елементи саме в тій послідовності, в якій вони були вставлені.
8. `zip` попарно обʼєднує ключі і значення а `dict` з цих пар створює словник.

---

## ООП МК (І)+

1. ```cpp
   char *s = "C++";
   std::cout << s << " ";
   s++;
   std::cout << s << " ";
   ```
  - Вивід: `C++ ++` - в другому випадку після `s++` вказівник зсунувся та `C` вже незахоплює.
2. ```cpp
   int a, b, c;
   cin >> a >> b >> c;
   // Вводим: 10 45.6 37
   cout << a << b << c;
   ```
  - Вивід: `10450`  - `a, b, c` мають тип int тому `45.6` зчитується як `45` а `cout` виводить значення підряд без пробілів.  `37` не зчиталось бо `45.6` залишає `.6` у потоці і читання `int c` на ньому ламається тому `c` лишається невизначеним і не виводиться.
3. ```cpp
   cout << 2 + "text" << endl;
   ```
  - Вивід: `xt`  - "text" це вказівник на масив символів і додавання `2` зсуває його на два символи вперед.
4. ```cpp
   int a = 14;
   int b = (++a, a + 10, 99 + a);
   cout << b;
   ```
  - Вивід:  `114` - бо оператор коми обчислює всі вирази зліва направо але результатом присвоєння стає останній тобто `99 + a` після `++a` де `a` вже дорівнює `15`.
5. ```cpp
   char s[] = "hello", t[] = "hello";
   if (s == t) std::cout << "True";
   ```
  - Вивід:  Нічого бо `s` і `t` різні масиви, вираз `s == t` порівнює їх адреси а не вміст рядків тому умова хибна.
6. ```cpp
   int a[] = {1, 2, 3, 4, 5, 6};
   std::cout << (1 + 3)[a] - a[0] + (a + 1)[2];
   ```
  - Вивід:  `8` - бо `(1 + 3)[a]` це `a[4]` тобто `5`, `a[0]` це `1`, `(a + 1)[2]` це `a[3]` тобто `4`, і виходить `5 - 1 + 4 = 8`.
7. ```cpp
   int i = 1, j = 2, k = 3, r;
   r = (i, j, k);
   std::cout << r << std::endl;
   ```
  - Вивід:  `3` - бо оператор коми обчислює всі вирази зліва направо але значенням усього виразу стає останній тобто `k`
8. ```cpp
   #define func(X) X*X
   int main()
   {
       int x = 5;
       double a = func(x + 1);
       std::cout << a;

       return 0;
   }
   ```
  - Вивід:  `11` - бо макрос `func(X)` не має дужок і `func(x + 1)` розкривається як `x + 1 * x + 1` що при `x = 5` дає `5 + 5 + 1 = 11`.