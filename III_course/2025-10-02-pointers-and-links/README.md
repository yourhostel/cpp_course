# Тема 4: Масиви об'єктів, вказівники та посилання

### 1) Передача за вказівником
  - Приклад функції `print_hex`, яка приймає `const char*` (рядок у вигляді масиву char) і друкує його вміст у шістнадцятковому представленні.
    Це `C style` роботи з рядками — масив символів з термінатором `'\0'`.
### 2) Робота з великими числами та рядками STL
  - Функція `fibonacci` обчислює `n`-е число Фібоначчі у типі `unsigned __int128`.
    Оскільки напряму вивести `__int128` у `cout` неможливо, використовується допоміжна функція `to_string_i128`, яка конвертує число у `std::string`.
    Це приклад другого підходу роботи з рядками e `C++ style` рядки (`std::string`), які динамічно керують пам’яттю.
### 3) Передача масиву за посиланням із шаблоном. Перевантаження
  - Використовується шаблон `template <size_t N>` у функції `isLeap(const int (&years)[N])`, що дозволяє передавати масив будь-якої довжини без явної передачі його розміру.
    - Є дві перевантажені версії isLeap:
      - `bool isLeap(int year)` — перевіряє окремий рік.
      - `void isLeap(const int (&years)[N])` — перевіряє масив років довільної довжини.

### 4) Вибір типу для індексів і розмірів у C++

| Тип          | Де використовувати | Плюси                                                                                                                            | Мінуси                                                                    |
|--------------|--------------------|----------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------|
| **`int`**    | - Маленькі масиви/цикли<br>- Коли можливі **негативні значення** (наприклад, ітерація назад) | - Простий і звичний<br>- Легше відлагоджувати (мінус видно)                                                                      | - Обмеження 32 біти (2 млрд)<br>- Не узгоджений із `sizeof` та STL-методами |
| **`size_t`** | - Кількість елементів (`.size()`, `sizeof`)<br>- Класичний цикл `for (size_t i = 0; i < N; i++)`<br>- Усі STL-контейнери (`vector`, `array`, `string`) | - Стандарт для розмірів<br>- Вистачає бітів (на 64-бітних системах - 64 біти)<br>- Захищає від переповнення при великих розмірах | - Це `unsigned`, при відніманні дає баги:<br>`0 - 1 = дуже велике число`  |
| **`ptrdiff_t`** | - Різниця між двома вказівниками або ітераторами<br>- Коли треба від’ємні індекси для STL | - Підписаний тип, сумісний з ітераторами STL<br>- Безпечніше для віднімання                                                      | - Використовується рідше, менш читабельний                                |
