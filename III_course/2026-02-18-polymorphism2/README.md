# Поліморфізм 2 

## Тема 3. Динамічний поліморфізм. Віртуальні функції.

- Завдання
  - 1 Піднесення числа `n` в степінь `р` — це множення числа `n` на себе `р` разів. Написати функцію з іменем `power()`, яка в ролі аргументів набуває значення типу `double` для `n` та значення типу `int` для `р`, повертаючи значення типу `double`. Для аргументу, що відповідає степеню числа, задайте значення за умовчанням, рівне 2, щоб за відсутності показника степеню за умови виклику функції число `n` підносилось в квадрат. 
    - Напишіть функцию `main()`, яка здійснює запит у користувача введення аргументів для функції `power()`, і відобразіть на екрані результати її роботи.
  - 2 Напишіть функцію з іменем `zeroSmaller()`, в яку передаються за допомою посилань два аргументи типа `int`, яка присвоює меншому з аргументів нульове значення. Напишіть программу для перевірки роботи функції.
  - 3 Напишіть функцію, що набуває в якості аргументів два значення типу `Distance` та повертає значення найбільшого з аргументів.

---

## Завдання 1 

Для коректної обробки від'ємних степенів:

$$n^p = \frac{1}{n^{|p|}}$$

Для модуля степеня:
```cpp
int absP = (p < 0) ? -p : p;
```

Якщо степінь від'ємний:
```cpp
double base = (p < 0) ? 1.0 / n : n;
```

### Логіка $O(|p|)$

- Ітеративно:
```cpp
double power(double n, int p)
{
    int absP = (p < 0) ? -p : p;
    double base = (p < 0) ? 1.0 / n : n;

    double result = 1.0;

    for(int i = 0; i < absP; i++)
    {
        result *= base;
    }

    return result;
}
```

- Рекурсивно:
```cpp
double power_recursive(double n, int p)
{
    if(p == 0) return 1.0;
    if(p < 0) return 1.0 / power_recursive(n, -p);
    return n * power_recursive(n, p - 1);
}
```

### Логіка $O \log(|p|$) бінарне піднесення
- У бінарному піднесенні до степеня використовується тотожність

$$ 
n^p =
\begin{cases}
\left(n^{p/2}\right)^2, & \text{якщо } p \text{ парне}, \\
n \cdot \left(n^{(p-1)/2}\right)^2, & \text{якщо } p \text{ непарне}.
\end{cases}
$$
- Тобто кожного кроку показник ділиться на 2. Це означає, що кількість кроків дорівнює кількості бітів у двійковому записі числа p.

- Ітеративне бінарне піднесення до степеня
```cpp
double power(double n, int p)
{
    int absP = (p < 0) ? -p : p;
    double base = (p < 0) ? 1.0 / n : n;
    
    double result = 1.0;

    while(absP > 0)
    {
        if(absP % 2 == 1)
            result *= base;

        base *= base;
        absP /= 2;
    }

    return result;
}
```

- Рекурсивне бінарне піднесення до степеня
```cpp
double power_recursive(double n, int p)
{
    if(p == 0) return 1.0;
    if(p < 0) return 1.0 / power_recursive(n, -p);

    double half = power_recursive(n, p / 2);
    if((p % 2) == 0) return half * half;
    return n * half * half;
}
```

### Поліморфізм в реалізації:
- Динамічний поліморфізм у цій реалізації забезпечується віртуальними методами базового класу PowerStrategy, які перевизначені у похідному класі FastPowerStrategy. Виклик методів power і power_recursive через вказівник або посилання на базовий тип визначається під час виконання програми відповідно до фактичного типу об’єкта. Для базового класу застосовується лінійний алгоритм, для похідного класу використовується швидке піднесення до степеня.

- ![1.png](screenshots/1.png)

---

## Завдання 2
