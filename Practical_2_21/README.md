# Рекурсивні функції

**Рекурсія** — це метод, при якому функція викликає саму себе.

Існують:

- **Пряма рекурсія** — функція викликає саму себе.
- **Непряма рекурсія** — кілька функцій викликають одна одну по черзі.

Рекурсія дозволяє звести складну задачу до простіших копій.  
Обов'язково потрібна **умова завершення**, щоб уникнути **нескінченного виклику**.

---

## Ключові терміни

| Термін                | Опис                                                                 |
|-----------------------|----------------------------------------------------------------------|
| Рекурсивний спуск     | Процес вкладених викликів функцій до досягнення умови завершення    |
| Рекурсивний підйом    | Повернення до попередніх викликів після досягнення умови завершення |
| Глибина рекурсії      | Максимальна кількість активних викликів функції у стеку             |
| Фрейм (stack frame)   | Локальний контекст кожного виклику (параметри, локальні змінні)     |

---

## Приклад: факторіал

```cpp
long fact(long n) {
    if (n == 0 || n == 1) return 1;
    return n * fact(n - 1);
}
```

Виклик `fact(3)` призводить до:

```
fact(3)
└── fact(2)
    └── fact(1) → 1 (завершення)
```

## Стан стека під час виклику fact(3)

| Рівень | n | Повертає |
|--------|---|----------|
| 1      | 3 | 3 * 2 = 6 |
| 2      | 2 | 2 * 1 = 2 |
| 3      | 1 | 1        |

---

## Приклад неефективної рекурсії

```cpp
long fib(int n) {
    if (n <= 1) return n;
    return fib(n - 1) + fib(n - 2);
}
```

❗ Рекурсія тут викликає **одні й ті самі значення багаторазово**, що призводить до **експоненціального зростання часу**.

---

## Коли рекурсія доречна

- Алгоритми, що природно описуються рекурсією (дерева, обходи графів)
- Коли важлива **компактність коду**, а не **максимальна швидкодія**

---

## Недоліки рекурсії

- Витрати пам’яті (кожен виклик → новий фрейм)
- Ризик переповнення стека
- Повторні обчислення без кешування (як у Fibonacci)

---





